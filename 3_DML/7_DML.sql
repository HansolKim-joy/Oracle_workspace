-- DML : 데이터 조작 언어
-- INSERT, UPDATE, DELETE

-- INSERT : 새로운 행을 추가 하는 구문(테이블 행 개수 증가)
-- INSERT INTO 테이블 명(컬럼 명, ...)
-- VALUES (데이터, ...)
INSERT INTO EMPLOYEE(EMP_ID, EMP_NAME, EMP_NO, EMAIL, PHONE, DEPT_CODE, JOB_CODE, SAL_LEVEL,
                SALARY, BONUS, MANAGER_ID, HIRE_DATE, ENT_DATE, ENT_YN)
VALUES(900, '장채현', '901123-1080503', 'jang_ch@kh.or.kr', '01055569512', 'D1', 'J7', 'S3',
        4300000, 0.2, '200', SYSDATE, NULL, DEFAULT);
        
SELECT * FROM EMPLOYEE;

ROLLBACK;

INSERT INTO EMPLOYEE
VALUES(900, '장채현', '901123-1080503', 'jang_ch@kh.or.kr', '01055569512', 'D1', 'J7', 'S3',
        4300000, 0.2, '200', SYSDATE, NULL, DEFAULT);
        
COMMIT;

-- 위의 INSERT문과 아래 INSERT문의 차이점 :
--          위에서는 컬럼 명의 순서가 바뀔 때 VALUES안에 들어가는 값이 그 컬럼 명에 맞춰 순서가 바뀌지만
--          아래에서는 이미 EMPLOYEE테이블에서 정해진 컬럼 명 순서에 맞춰 VALUES에 컬럼 값을 넣어야 한다.

-- 서브쿼리를 이용하여 INSERT
CREATE TABLE EMP_01(
    EMP_ID NUMBER,
    EMP_NAME VARCHAR2(30),
    DEPT_TITLE VARCHAR2(20)
);

INSERT INTO EMP_01(
    SELECT EMP_ID, EMP_NAME, DEPT_TITLE
    FROM EMPLOYEE
        LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
);

SELECT * FROM EMP_01;

-- INSERT ALL : 두 개 이상의 테이블에 한 번에 삽입 가능
-- 서브쿼리가 사용하는 테이블이 같을때, 각 서브쿼리의 조건절이 같을 때 사용 가능 
CREATE TABLE EMP_DEPT_D1
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE 
    FROM EMPLOYEE
    WHERE 1 = 0;

SELECT * FROM EMP_DEPT_D1;

CREATE TABLE EMP_MANAGER
AS SELECT EMP_ID, EMP_NAME, MANAGER_ID
    FROM EMPLOYEE
    WHERE 1 = 0;
    
SELECT * FROM EMP_MANAGER;

INSERT ALL
INTO EMP_DEPT_D1 VALUES (EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE)
INTO EMP_MANAGER VALUES (EMP_ID, EMP_NAME, MANAGER_ID)
    SELECT EMP_ID, EMP_NAME, DEPT_CODE, MANAGER_ID, HIRE_DATE
    FROM EMPLOYEE
    WHERE DEPT_CODE = 'D1';

CREATE TABLE EMP_OLD -- 2000년 1월 1일 이전에 입사한 사원 정보
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
    FROM EMPLOYEE
    WHERE 1 = 0;

CREATE TABLE EMP_NEW -- 그 후에 입사한 사원 정보
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
    FROM EMPLOYEE
    WHERE 1 = 0;

COMMIT;

INSERT INTO EMP_OLD(
    SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
    FROM EMPLOYEE
    WHERE HIRE_DATE < '2000/01/01'
);

INSERT INTO EMP_NEW(
    SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
    FROM EMPLOYEE
    WHERE HIRE_DATE >= '2000/01/01'
);

SELECT * FROM EMP_OLD;
SELECT * FROM EMP_NEW;

ROLLBACK;

-- 조건절이 다를 때 방법
INSERT ALL
WHEN HIRE_DATE < '2000/01/01' THEN 
    INTO EMP_OLD VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)
WHEN HIRE_DATE >= '2000/01/01' THEN
    INTO EMP_NEW VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)
SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
FROM EMPLOYEE;

-- 다른 방법 
INSERT ALL
WHEN HIRE_DATE < '2000/01/01' THEN 
    INTO EMP_OLD VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)
ELSE
    INTO EMP_NEW VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)
SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
FROM EMPLOYEE;

-- UPDATE : 테이블에 기록된 컬럼의 값을 수정하는 구문(행 개수 변화 X)
CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY;

UPDATE DEPT_COPY
SET DEPT_TITLE = '전략기획팀'
WHERE DEPT_ID = 'D9';

-- WHERE절 넣지 않으면 전체가 바뀜 => WHERE절 잘 챙기기
UPDATE DEPT_COPY
SET DEPT_TITLE = '전략기획팀';

ROLLBACK;

-- UPDATE 시에도 서브쿼리 가능
-- 평상 시 유재식 사원을 부러워하던 방명수 사원의 급여와 보너스를 유재식 사원과 동일하게 변경해주기로 했다.
CREATE TABLE EMP_SALARY
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY, BONUS
    FROM EMPLOYEE;

SELECT * FROM EMP_SALARY;

SELECT * FROM EMP_SALARY
WHERE EMP_NAME IN ('유재식', '방명수');

UPDATE EMP_SALARY
SET SALARY = (SELECT SALARY
                FROM EMPLOYEE
                WHERE EMP_NAME = '유재식'),
    BONUS = (SELECT BONUS
                FROM EMPLOYEE
                WHERE EMP_NAME = '유재식')
WHERE EMP_NAME = '방명수';

ROLLBACK;

UPDATE EMP_SALARY
SET (SALARY, BONUS) = (SELECT SALARY, BONUS
                        FROM EMPLOYEE
                        WHERE EMP_NAME = '유재식')
WHERE EMP_NAME IN ('방명수','노옹철','전형돈','정중하','하동운');

SELECT * FROM EMP_SALARY
WHERE EMP_NAME IN ('방명수','노옹철','전형돈','정중하','하동운');

-- EMP_SALARY테이블에서 아시아지역에 근무하는 직원의 보너스를 0.3으로 변경
-- 아시아에 근무하는 직원 조회(사번, 이름, 급여, 보너스, 지역 명)
SELECT EMP_ID, EMP_NAME, SALARY, BONUS, LOCAL_NAME
FROM EMP_SALARY
    JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
    JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE)
WHERE LOCAL_NAME LIKE 'ASIA%';

UPDATE EMP_SALARY
SET BONUS = 0.3
WHERE EMP_ID IN (SELECT EMP_ID
                 FROM EMP_SALARY
                    JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
                    JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE)
                WHERE LOCAL_NAME LIKE 'ASIA%');

-- 제약 조건이 들어가있으면 제약 조건을 위배하는 것을 넣을 수 없다.
UPDATE EMPLOYEE
SET EMP_NAME = NULL
WHERE EMP_ID = 200;

-- DELETE : 테이블의 행을 삭제하는 구문(행 개수 줄어듦)
COMMIT;

DELETE FROM EMPLOYEE
WHERE EMP_NAME = '장채현';

SELECT * FROM EMPLOYEE;

ROLLBACK;

SELECT * FROM EMPLOYEE;

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(DEPT_CODE) REFERENCES DEPARTMENT;

DELETE FROM DEPARTMENT
WHERE DEPT_ID = 'D1';
-- integrity constraint (KH.SYS_C007160) violated - child record found
-- 자식테이블인 DEPARTMENT테이블이 참조하고 있기 때문에 삭제 할 수 없다는 에러 발생

-- 삭제 시 FOREIGN KEY 제약조건으로 컬럼 삭제가 불가능할 경우 제약조건 비활성화 가능
ALTER TABLE EMPLOYEE
DISABLE CONSTRAINT SYS_C007160 CASCADE;

DELETE FROM DEPARTMENT
WHERE DEPT_ID = 'D1';

-- 여기에서는 D1이 삭제 되었지만
SELECT * FROM DEPARTMENT;

-- 여기서는 D1을 갖고 있는 정보들이 살아있음
SELECT * FROM EMPLOYEE
WHERE DEPT_CODE = 'D1';

ROLLBACK;

ALTER TABLE EMPLOYEE
ENABLE CONSTRAINT SYS_C007160;

-- TRUNCATE : 테이블의 전체 행 삭제시 사용
-- DELETE보다 수행속도가 더 빠르나 ROLLBACK을 통해 복구 불가능

SELECT * FROM EMP_SALARY;
COMMIT;

DELETE FROM EMP_SALARY;
-- 24개 행 이(가) 삭제되었습니다.

ROLLBACK;

TRUNCATE TABLE EMP_SALARY;
-- Table EMP_SALARY이(가) 잘렸습니다.
